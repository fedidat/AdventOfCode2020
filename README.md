## AdventOfCode2019

These will be my solutions for [AdventOfCode](https://adventofcode.com/) 2020. This year I'm trying to try out as many languages as possible. Here we go!

### Standalone problems: one language a day!

- Day 1: Elixir. Nope, this is basically Ruby on Erlang and I dislike Ruby. Refactoring to allow other languages.
- Day 2: Kotlin. This is special, I might come back to it.
- Day 3: Java. This is my home language and I really enjoy it, the syntax is so consistent. Java 15 is really powerful as well, too bad half the world is stuck on Java 8.
- Day 4: C++. Back after many years. It changed a lot and it's decent but you can feel that it's an old language with piles of bandaid. Rust is the worthy successor.
- Day 5: Rust. It's been a year and it's really very powerful. It's notably much better than C++ in most areas but the borrow checker and other features are bothersome for quick prototyping like this. At least everything makes sense.
- Day 6: Typscript and Deno. This is good, perhaps better than Java. Strong typing, syntax that makes sense, easy prototyping almost to the level of Python. Install [Deno](https://deno.land/manual@v1.5.4/getting_started/installation) and run `deno test --allow-read`. Regarding Deno it's a better experience than node.js from the standard library alone, but I've barely tried all the features.
- Day 7: Swift. It was hard to setup for Linux but doable, at least Apple made an effort. And it works rather well, although somewhat Go-like in syntax. The package system is nice.
- Day 9: Go. Just as horrible as I remembered. No exceptions, no generics (and no OOP as far as I'm concerned), extremely limited standard library, very opinionated and limited syntax... Sure, it has some amazing aspects like green threads and build time, but how would anyone accept to work with such limited tooling?

Lined up: Scala, C#, Perl, Bash, Lua, Racket, Common Lisp, F# and Haskell.

### Incremental problems

Days 8 (and counting) are not included in this year's one-language-a-day, and are instead done in Jupyter notebooks with Python.

Re-implementing the virtual machine in another language every day would be an interesting language but would be repetitive and more time-consuming than I can afford.
