# AdventOfCode2019

These will be my solutions for [AdventOfCode](https://adventofcode.com/) 2020. This year I'm trying to try out as many languages as possible. Here we go!

## One language a day

### Day 1: Elixir

Nope, this is basically Ruby on Erlang and I dislike Ruby.

### Day 3: Java 15

This is my home language and I really enjoy it, the syntax is so consistent. Java 15 is really powerful as well, too bad half the world is stuck on Java 8.

### Day 4: C++20

Back after many years. It changed a lot and it's decent but you can feel that it's an old language with piles of bandaid. Rust is the worthy successor.

### Day 5: Rust

It's been a year and it's really very powerful. It's notably much better than C++ in most areas but the borrow checker and other features are bothersome for quick prototyping like this. At least everything makes sense.

### Day 6: Typscript and Deno

This is good, perhaps better than Java. Strong typing, syntax that makes sense, easy prototyping almost to the level of Python. Install [Deno](https://deno.land/manual@v1.5.4/getting_started/installation) and run `deno test --allow-read`. Regarding Deno it's a better experience than node.js from the standard library alone, but I've barely tried all the features.

### Day 7: Swift

It was hard to setup for Linux but doable, at least Apple made an effort. And it works rather well, although somewhat Go-like in syntax. The package system is nice.

### Day 8: Python 3 with Jupyter notebook

There's just no beating Python for quick prototyping, although who knows, maybe another language will take the crown.

### Day 9: Go

Just as horrible as I remembered. No exceptions, no generics (and no OOP as far as I'm concerned), extremely limited standard library, very opinionated and limited syntax... Sure, it has some amazing aspects like green threads and build time, but how would anyone accept to work with such limited tooling?

### Day 10: Scala 3 (dotty) with SBT

I didn't get it last year but I'm really digging it now! It's a much more productive Java without going overboard like Kotlin. And I barely scratched the surface as I had no time to explore parallelism. I remember SBT being painful but I now realize it is fairly similar to Gradle but with Scala itself instead of a minor scripting language like Groovy.

### Day 11: C# .NET Core 5.0

Wow it really fell behind Java. You can say it tried to copy it but it didn't go well. That way really painful. In addition, the .sln and .csproj formats are awful and mandatory and LINQ requires unpacking custom objects. I see no future for this language.

### Day 12: Perl

Very flexible scripting language, although it may take some time to get used to reading it, it's hard to decipher... CPAN is solid but I hope to never need to diagnose any issue with it.

### Day 13: Dlang

Another exciting language. It feels oddly close to Rust, I suppose as another system language, but with none of the safety features and much more restricted syntactic sugar. It also feels related to Scala through the pipe design. The learning curve may be slightly steep however, and the package manager is mundane json.

## Coming up

Lined up: Bash, Lua, Racket, Common Lisp, F# and Haskell.

More in case no problems build up: C, PHP, JavaScript, Ruby, Julia, Awk, Ocaml, Clojure, R/Processing.
